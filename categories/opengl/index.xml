<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>OpenGL on 开摆教科书</title>
        <link>https://whitedabaic.github.io/categories/opengl/</link>
        <description>Recent content in OpenGL on 开摆教科书</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>开摆教科书</copyright>
        <lastBuildDate>Mon, 07 Apr 2025 13:50:28 +0800</lastBuildDate><atom:link href="https://whitedabaic.github.io/categories/opengl/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>OpenGL学习笔记（五）</title>
        <link>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</link>
        <pubDate>Mon, 07 Apr 2025 13:50:28 +0800</pubDate>
        
        <guid>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</guid>
        <description></description>
        </item>
        <item>
        <title>OpenGL学习笔记（四）</title>
        <link>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
        <pubDate>Tue, 01 Apr 2025 20:15:48 +0800</pubDate>
        
        <guid>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
        <description>&lt;h2 id=&#34;绘制三角形&#34;&gt;绘制三角形
&lt;/h2&gt;&lt;h3 id=&#34;重要概念&#34;&gt;重要概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;顶点数组对象：Vertex Array Object，VAO&lt;/li&gt;
&lt;li&gt;顶点缓冲对象：Vertex Buffer Object，VBO&lt;/li&gt;
&lt;li&gt;元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;绘制图形的大致流程&#34;&gt;绘制图形的大致流程
&lt;/h3&gt;&lt;p&gt;在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。&lt;/p&gt;
&lt;p&gt;图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。&lt;/p&gt;
&lt;p&gt;首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而这样一个顶点的数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置(译注1)和一些颜色值组成的吧。&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor= #00ff80&gt;
为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做&lt;b&gt;图元(Primitive)&lt;/b&gt;，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：&lt;b&gt;GL_POINTS&lt;/b&gt;、&lt;b&gt;GL_TRIANGLES&lt;/b&gt;、&lt;b&gt;GL_LINE_STRIP&lt;/b&gt;。
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;图形渲染管线的第一个部分是&lt;font color=red&gt;顶点着色器(Vertex Shader)&lt;/font&gt;，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。&lt;/p&gt;
&lt;p&gt;顶点着色器阶段的输出可以选择性地传递给&lt;font color=red&gt;几何着色器(Geometry Shader)&lt;/font&gt;。几何着色器将一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。在这个例子中，它从给定的形状中生成第二个三角形。&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;图元装配(Primitive Assembly)&lt;/font&gt;阶段将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状；本节例子中是两个三角形。&lt;/p&gt;
&lt;p&gt;图元装配阶段的输出会被传入&lt;font color=red&gt;光栅化阶段(Rasterization Stage)&lt;/font&gt;，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行&lt;font color=red&gt;裁切(Clipping)&lt;/font&gt;。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;片段着色器&lt;/font&gt;的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。&lt;/p&gt;
&lt;p&gt;在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做&lt;font color=red&gt;Alpha测试&lt;/font&gt;和&lt;font color=red&gt;混合(Blending)&lt;/font&gt;阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查&lt;font color=red&gt;alpha&lt;/font&gt;值（alpha值定义了一个物体的透明度）并对物体进行&lt;font color=red&gt;混合(Blend)&lt;/font&gt;。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。&lt;/p&gt;
&lt;h3 id=&#34;顶点着色器&#34;&gt;顶点着色器
&lt;/h3&gt;&lt;p&gt;顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 标明版本号和核心模式
#version 330 core
// 使用in关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它并没有类型in、out或是uniform的声明，而是直接使用，且在后面的程序中也未被引用。原来它是默认是归一化的&lt;b&gt;裁剪空间坐标&lt;/b&gt;，xyz各个维度的范围为-1到1，仅能在顶点着色器中使用，&lt;b&gt;既是输入也是输出&lt;/b&gt;。gl_Position赋值范围就是float的取值范围(32位)，只不过只有[-1,1]区间的片元被绘制。它是&lt;b&gt;vec4&lt;/b&gt;类型的，不能重声明为dvec4等类型。&lt;/p&gt;
&lt;p&gt;gl_Position可以通过视角划分转换为标准化设备空间中的笛卡尔坐标：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vec3 ndc = gl_Position.xyz / gl_Position.w;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编译着色器&#34;&gt;编译着色器
&lt;/h3&gt;&lt;p&gt;我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为&lt;kbd&gt;unsigned int&lt;/kbd&gt;，然后用&lt;font color= red&gt;glCreateShader&lt;/font&gt;创建这个着色器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们把需要创建的着色器类型以参数形式提供给&lt;font color= red&gt;glCreateShader&lt;/font&gt;。由于我们正在创建一个顶点着色器，传递的参数是&lt;font color= red&gt;GL_VERTEX_SHADER&lt;/font&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// glShaderSource(着色器对象，传递代码字符串的数量，顶点着色器源码，NULL)
glShaderSource(vertexShader, 1, &amp;amp;vertexShaderSource, NULL);
glCompileShader(vertexShader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用&lt;font color= red&gt;glCompileShader&lt;/font&gt;检测编译时错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int  success;   // 判断是否成功编译
char infoLog[512];  // 储存错误消息
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;amp;success);   // 检查是否成功
if(!success)
{
    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);   // 打印错误信息
    std::cout &amp;lt;&amp;lt; &amp;quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&amp;quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;片段着色器&#34;&gt;片段着色器
&lt;/h3&gt;&lt;p&gt;片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor= #00ff80&gt;在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;#version 330 core
// 片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。声明输出变量可以使用out关键字
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用GL_FRAGMENT_SHADER常量作为着色器类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &amp;amp;fragmentShaderSource, NULL);
glCompileShader(fragmentShader);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;着色器程序&#34;&gt;着色器程序
&lt;/h3&gt;&lt;p&gt;着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们&lt;font color=red&gt;链接(Link)&lt;/font&gt;为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。&lt;/p&gt;
&lt;p&gt;当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int shaderProgram;
shaderProgram = glCreateProgram();              // 返回新创建程序对象的ID引用
glAttachShader(shaderProgram, vertexShader);    // 附加顶点着色器
glAttachShader(shaderProgram, fragmentShader);  // 附加片段着色器
glLinkProgram(shaderProgram);                   // 链接着色器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;amp;success);
if(!success) {
    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
    std::cout &amp;lt;&amp;lt; &amp;quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&amp;quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glUseProgram(shaderProgram);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。&lt;/p&gt;
&lt;h3 id=&#34;顶点输入&#34;&gt;顶点输入
&lt;/h3&gt;&lt;p&gt;以屏幕中间为（0，0），OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做&lt;font color=red&gt;标准化设备坐标(Normalized Device Coordinates)&lt;/font&gt;，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float vertices[] = {
    -0.5f, -0.5f, 0.0f,
    0.5f, -0.5f, 0.0f,
    0.0f,  0.5f, 0.0f
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/ndc.png&#34;
	width=&#34;400&#34;
	height=&#34;197&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/ndc_hu_61855d1a835c9ccd.png 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/ndc_hu_68634e839573107a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;203&#34;
		data-flex-basis=&#34;487px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们通过&lt;font color=red&gt;顶点缓冲对象(Vertex Buffer Objects, VBO)&lt;/font&gt;管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。&lt;/p&gt;
&lt;p&gt;这个缓冲有一个独一无二的ID，所以我们可以使用&lt;font color=red&gt;glGenBuffers&lt;/font&gt;函数生成一个带有缓冲ID的VBO对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int VBO;
glGenBuffers(1, &amp;amp;VBO);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是&lt;font color=red&gt;GL_ARRAY_BUFFER&lt;/font&gt;。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用&lt;font color=red&gt;glBindBuffer&lt;/font&gt;函数把新创建的缓冲绑定到&lt;font color=red&gt;GL_ARRAY_BUFFER&lt;/font&gt;目标上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glBindBuffer(GL_ARRAY_BUFFER, VBO);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这一刻起，我们使用的任何（在&lt;font color=red&gt;GL_ARRAY_BUFFER&lt;/font&gt;目标上的）缓冲调用都会用来配置当前绑定的缓冲(&lt;font color=red&gt;VBO&lt;/font&gt;)。然后我们可以调用&lt;font color=red&gt;glBufferData&lt;/font&gt;函数，它会把之前定义的顶点数据复制到缓冲的内存中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// glBufferData(目标缓冲的类型, 传输数据的大小(以字节为单位), 实际数据, 显卡如何管理给定的数据)
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GL_STATIC_DRAW ：数据不会或几乎不会改变。&lt;/li&gt;
&lt;li&gt;GL_DYNAMIC_DRAW：数据会被改变很多。&lt;/li&gt;
&lt;li&gt;GL_STREAM_DRAW ：数据每次绘制时都会改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;顶点数组对象&#34;&gt;顶点数组对象
&lt;/h3&gt;&lt;p&gt;&lt;font color=red&gt;顶点数组对象(Vertex Array Object, VAO)&lt;/font&gt;可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor= #00ff80&gt;OpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;一个顶点数组对象会储存以下这些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=red&gt;glEnableVertexAttribArray&lt;/font&gt;和&lt;font color=red&gt;glDisableVertexAttribArray&lt;/font&gt;的调用。&lt;/li&gt;
&lt;li&gt;通过&lt;font color=red&gt;glVertexAttribPointer&lt;/font&gt;设置的顶点属性配置。&lt;/li&gt;
&lt;li&gt;通过&lt;font color=red&gt;glVertexAttribPointer&lt;/font&gt;调用与顶点属性关联的顶点缓冲对象。
&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_array_objects.png&#34;
	width=&#34;546&#34;
	height=&#34;369&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_array_objects_hu_99666cf09578e4eb.png 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_array_objects_hu_41673852eff8a7d9.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建一个VAO：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int VAO;
glGenVertexArrays(1, &amp;amp;VAO);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..
// 1. 绑定VAO
glBindVertexArray(VAO);
// 2. 把顶点数组复制到缓冲中供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

[...]

// ..:: 绘制代码（渲染循环中） :: ..
// 4. 绘制物体
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
someOpenGLFunctionThatDrawsOurTriangle();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;链接顶点属性&#34;&gt;链接顶点属性
&lt;/h3&gt;&lt;p&gt;顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。&lt;/p&gt;
&lt;p&gt;我们的顶点缓冲数据会被解析为下面这样子：
&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_attribute_pointer.png&#34;
	width=&#34;666&#34;
	height=&#34;162&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_attribute_pointer_hu_31097647ac8aa0a6.png 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_attribute_pointer_hu_b260df53f11ad7c3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;411&#34;
		data-flex-basis=&#34;986px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位置数据被储存为32位（4字节）浮点值。&lt;/li&gt;
&lt;li&gt;每个位置包含3个这样的值。&lt;/li&gt;
&lt;li&gt;在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。&lt;/li&gt;
&lt;li&gt;数据中第一个值在缓冲开始的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数指定我们要配置的顶点属性。对应顶点着色器中&lt;kbd&gt;layout(location = 0)&lt;/kbd&gt;location值。&lt;/li&gt;
&lt;li&gt;第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。&lt;/li&gt;
&lt;li&gt;第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。&lt;/li&gt;
&lt;li&gt;下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。&lt;/li&gt;
&lt;li&gt;第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。&lt;/li&gt;
&lt;li&gt;最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor= #00ff80&gt;每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id=&#34;画出三角形&#34;&gt;画出三角形
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;glUseProgram(shaderProgram);
glBindVertexArray(VAO);
// glDrawArrays(OpenGL图元的类型，顶点数组的起始索引，绘制多少个顶点)
glDrawArrays(GL_TRIANGLES, 0, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;元素缓冲区&#34;&gt;元素缓冲区
&lt;/h3&gt;&lt;p&gt;绘制矩形需要两个三角形，会有两个顶点重合，可以使用索引绘制(Indexed Drawing)。首先需要定义不重复的点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float vertices[] = {
0.5f, 0.5f, 0.0f,   // 右上角
0.5f, -0.5f, 0.0f,  // 右下角
-0.5f, -0.5f, 0.0f, // 左下角
-0.5f, 0.5f, 0.0f   // 左上角
};

unsigned int indices[] = {
    // 注意索引从0开始! 
    // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，
    // 这样可以由下标代表顶点组合成矩形

    0, 1, 3, // 第一个三角形
    1, 2, 3  // 第二个三角形
};

// 创建元素缓冲对象
unsigned int EBO;
glGenBuffers(1, &amp;amp;EBO);

// 把索引复制到缓冲里
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
// glDrawElements(绘制的模式，顶点的个数，索引的类型，EBO中的偏移量)
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_array_objects_ebo.png&#34;
	width=&#34;546&#34;
	height=&#34;369&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_array_objects_ebo_hu_658bba07dc2a58b3.png 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/vertex_array_objects_ebo_hu_f4475b34d23a5a9c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor= #00ff80&gt;&lt;b&gt;线框模式(Wireframe Mode)&lt;/b&gt;
&lt;p&gt;要想用线框模式绘制你的三角形，你可以通过glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>OpenGL学习笔记（三）</title>
        <link>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
        <pubDate>Tue, 01 Apr 2025 12:28:44 +0800</pubDate>
        
        <guid>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
        <description>&lt;h2 id=&#34;导入头文件&#34;&gt;导入头文件
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;glad/glad.h&amp;gt;
#include &amp;lt;GLFW/glfw3.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;初始化glfw&#34;&gt;初始化GLFW
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 初始化GLFW
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;glfwInit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 使用OpenGL版本为4.6，将主版本号(Major)设为4，次版本号(Minor)设为6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;glfwWindowHint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLFW_CONTEXT_VERSION_MAJOR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glfwWindowHint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLFW_CONTEXT_VERSION_MINOR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 告诉GLFW我们使用的是核心模式(Core-profile)。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集（没有我们已不再需要的向后兼容特性）。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;glfwWindowHint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLFW_OPENGL_PROFILE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GLFW_OPENGL_CORE_PROFILE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果使用的是Mac OS X系统，你还需要加下面这行代码到你的初始化代码中这些配置才能起作用。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用&lt;font color=red&gt;glfwWindowHint&lt;/font&gt;函数来配置GLFW。&lt;font color=red&gt;glfwWindowHint&lt;/font&gt;函数的第一个参数代表选项的名称，我们可以从很多以&lt;kbd&gt;GLFW_&lt;/kbd&gt;开头的枚举值中选择；第二个参数接受一个整型，用来设置这个选项的值。该函数的所有的选项以及对应的值都可以在&lt;a class=&#34;link&#34; href=&#34;https://www.glfw.org/docs/latest/window.html#window_hints&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GLFW’s window handling&lt;/a&gt;这篇文档中找到。&lt;/p&gt;
&lt;h2 id=&#34;创建窗口对象&#34;&gt;创建窗口对象
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 创建宽800，高600，标题为“LearnOpenGL”的窗口。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLFWwindow&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;window&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;glfwCreateWindow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;800&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;600&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;LearnOpenGL&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Failed to create GLFW window&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glfwTerminate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 将当前窗口设置为上下文。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;glfwMakeContextCurrent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;font color=red&gt;glfwCreateWindow&lt;/font&gt;函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题），这里我们使用&amp;quot;LearnOpenGL&amp;quot;，当然你也可以使用你喜欢的名称。最后两个参数我们暂时忽略。这个函数将会返回一个&lt;font color=red&gt;GLFWwindow&lt;/font&gt;对象，我们会在其它的GLFW操作中使用到。创建完窗口我们就可以通知GLFW将我们窗口的上下文设置为当前线程的主上下文了。&lt;/p&gt;
&lt;h2 id=&#34;glad&#34;&gt;GLAD
&lt;/h2&gt;&lt;p&gt;GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gladLoadGLLoader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLADloadproc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;glfwGetProcAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Failed to initialize GLAD&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;视口&#34;&gt;视口
&lt;/h2&gt;&lt;p&gt;在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用&lt;font color=red&gt;glViewport&lt;/font&gt;函数来设置视口的尺寸(Dimension)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glViewport(0, 0, 800, 600);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=red&gt;glViewport&lt;/font&gt;函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。&lt;/p&gt;
&lt;p&gt;调整窗口大小的回调函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;framebuffer_size_callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLFWwindow&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glViewport&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;渲染循环&#34;&gt;渲染循环
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;glfwWindowShouldClose&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glfwSwapBuffers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glfwPollEvents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=red&gt;glfwWindowShouldClose&lt;/font&gt;函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话，该函数返回&lt;kbd&gt;true&lt;/kbd&gt;，渲染循环将停止运行，之后我们就可以关闭应用程序。&lt;/li&gt;
&lt;li&gt;&lt;font color=red&gt;glfwPollEvents&lt;/font&gt;函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。&lt;/li&gt;
&lt;li&gt;&lt;font color=red&gt;glfwSwapBuffers&lt;/font&gt;函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor= #00ff7f&gt;
&lt;b&gt;双缓冲(Double Buffer)&lt;/b&gt;
&lt;p&gt;应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。&lt;b&gt;前&lt;/b&gt;缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在&lt;b&gt;后&lt;/b&gt;缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h2 id=&#34;输入&#34;&gt;输入
&lt;/h2&gt;&lt;p&gt;使用GLFW的&lt;font color=red&gt;glfwGetKey&lt;/font&gt;函数，它需要一个窗口以及一个按键作为输入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;processInput&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLFWwindow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;glfwGetKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GLFW_KEY_ESCAPE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GLFW_PRESS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;glfwSetWindowShouldClose&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在程序主循环调用它&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;glfwWindowShouldClose&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;processInput&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glfwSwapBuffers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glfwPollEvents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;自定义颜色清空屏幕&#34;&gt;自定义颜色清空屏幕
&lt;/h2&gt;&lt;p&gt;通过调用&lt;font color=red&gt;glClear&lt;/font&gt;函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有&lt;kbd&gt;GL_COLOR_BUFFER_BIT&lt;/kbd&gt;，&lt;kbd&gt;GL_DEPTH_BUFFER_BIT&lt;/kbd&gt;和&lt;kbd&gt;GL_STENCIL_BUFFER_BIT&lt;/kbd&gt;。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;glfwWindowShouldClose&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 输入
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;processInput&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 渲染指令
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;glClearColor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.2f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.3f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.3f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glClear&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 检查并调用事件，交换缓冲
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;glfwSwapBuffers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;glfwPollEvents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;除了&lt;font color=red&gt;glClear&lt;/font&gt;之外，我们还调用了&lt;font color=red&gt;glClearColor&lt;/font&gt;来设置清空屏幕所用的颜色。当调用&lt;font color=red&gt;glClear&lt;/font&gt;函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为&lt;font color=red&gt;glClearColor&lt;/font&gt;里所设置的颜色。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。&lt;/p&gt;
&lt;h2 id=&#34;释放分配的所有资源&#34;&gt;释放分配的所有资源
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;glfwTerminate();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/finish.png&#34;
	width=&#34;799&#34;
	height=&#34;641&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/finish_hu_5a15cd21f965dfd8.png 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/finish_hu_be2794c5dce2cab1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;299px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>OpenGL学习笔记（二）</title>
        <link>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
        <pubDate>Mon, 31 Mar 2025 21:13:25 +0800</pubDate>
        
        <guid>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
        <description>&lt;h2 id=&#34;创建窗口&#34;&gt;创建窗口
&lt;/h2&gt;&lt;p&gt;在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。&lt;/p&gt;
&lt;h3 id=&#34;前期准备&#34;&gt;前期准备
&lt;/h3&gt;&lt;p&gt;本次学习使用VS2022 IDE，GLFW3.4，GLAD4.6&lt;/p&gt;
&lt;h4 id=&#34;glfw&#34;&gt;GLFW
&lt;/h4&gt;&lt;p&gt;GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。&lt;/p&gt;
&lt;p&gt;在&lt;a class=&#34;link&#34; href=&#34;https://www.glfw.org/download.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GLFW官网&lt;/a&gt;下载源码包，用CMake创建GLFW工程文件，然后编译它，在&lt;code&gt;src/Debug&lt;/code&gt;文件内可以找到编译的库&lt;strong&gt;glfw3.lib&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;glad&#34;&gt;GLAD
&lt;/h4&gt;&lt;p&gt;到这里还没有结束，我们仍然还有一件事要做。因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在Windows上会是类似这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 定义函数原型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GL_GENBUFFERS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLsizei&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GLuint&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 找到正确的函数并赋值给函数指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GL_GENBUFFERS&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;glGenBuffers&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GL_GENBUFFERS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wglGetProcAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;glGenBuffers&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 现在函数可以被正常调用了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GLuint&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;glGenBuffers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;你可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。幸运的是，有些库能简化此过程，其中GLAD是目前最新，也是最流行的库。&lt;/p&gt;
&lt;p&gt;打开&lt;a class=&#34;link&#34; href=&#34;https://glad.dav1d.de/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GLAD官网&lt;/a&gt;下载glad.zip解压后获得include文件夹和src文件夹。&lt;/p&gt;
&lt;h3 id=&#34;创建vs工程并进行链接&#34;&gt;创建VS工程并进行链接
&lt;/h3&gt;&lt;p&gt;创建一个空项目，创建vendor文件夹，将Glad和GLFW的include文件以及lib放进去，进入Project Properties(工程属性，在解决方案窗口里右键项目)，然后选择VC++ Directories(VC++ 目录)选项卡。
&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/include.png&#34;
	width=&#34;1714&#34;
	height=&#34;801&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/include_hu_7d89acbbf320738a.png 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/include_hu_9394f7f6a7ae50c9.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;213&#34;
		data-flex-basis=&#34;513px&#34;
	
&gt;
现在VS可以找到所需的所有文件了。然后需要在Linker(链接器)选项卡里的Input(输入)选项卡里添加glfw3.lib和opengl32.lib这个文件：
&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/lib.png&#34;
	width=&#34;1168&#34;
	height=&#34;804&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/lib_hu_4cc86c74e88a2792.png 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/lib_hu_d18fd770973ed4b4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;145&#34;
		data-flex-basis=&#34;348px&#34;
	
&gt;
最后将glad.c包括在项目中。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>OpenGL学习笔记（一）</title>
        <link>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
        <pubDate>Mon, 31 Mar 2025 18:41:47 +0800</pubDate>
        
        <guid>https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
        <description>&lt;h2 id=&#34;opengl总览&#34;&gt;OpenGL总览
&lt;/h2&gt;&lt;p&gt;OpenGL只有框架没有实现，换句话说就是OpenGL只有函数声明没有源文件实现，类似于接口和虚函数。所有的实现是显卡生产商提供。比如NVIDIA或者AMD就要自己实现OpenGL函数内容，所以不同的生产商可以对自己的产品提供优化，毕竟代码是自己写的。&lt;/p&gt;
&lt;p&gt;OpenGL函数库相关的API有核心库(gl)，实用库(glu)，辅助库(aux)、实用工具库(glut)，窗口库(glx、agl、wgl)和扩展函数库等。gl是核心，glu是对gl的部分封装。glx、agl、wgl 是针对不同窗口系统的函数。glut是为跨平台的OpenGL程序的工具包，比aux功能强大（aux很大程度上已经被glut库取代）。扩展函数库是硬件厂商为实现硬件更新利用OpenGL的扩展机制开发的函数。&lt;/p&gt;
&lt;h2 id=&#34;gultfreeglutglewglfwglad的联系与区别&#34;&gt;gult/freeglut/glew/glfw/glad的联系与区别
&lt;/h2&gt;&lt;h3 id=&#34;1glut&#34;&gt;1.glut
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.opengl.org/resources/libraries/glut/glut_downloads.php&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OpenGL Utility Toolkit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有32位的库文件下载，glutdlls37beta.zip，但是版本太老了，理应被时代淘汰，不推荐使用。gult最后版本v3.7beta的历史可追溯至1998年8月，且该项目已经被废弃。它的许可证禁止任何人发布修改后的库代码。&lt;/p&gt;
&lt;p&gt;这部分函数以glut开头，主要包括窗口操作函数，窗口初始化、窗口大小、窗口位置等函数；回调函数：响应刷新消息、键盘消息、鼠标消息、定时器函数等；创建复杂的三维物体；菜单函数；程序运行函数。gult对应的开源实现是freegult。&lt;/p&gt;
&lt;h3 id=&#34;2freeglut&#34;&gt;2.freeglut
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://freeglut.sourceforge.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;FreeGLUT is a free-software/open-source alternative to the OpenGL Utility Toolkit (GLUT) library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为OpenGL没有窗口管理的功能，所以很多热心的人写了工具来支持这些功能，比如早期的glut，现在的freeglut等。&lt;/p&gt;
&lt;p&gt;freeglut完全兼容glut，是glut的代替品，开源，功能齐全。目前来看，freeglut 3.0版本比其它版本稳定，推荐使用。帕维尔在1999年12月1日开始freeglut的开发。目前，该项目几乎可以100%的替代原来的GLUT，只有少数差别（如，the abandonment of SGI-specific features，按钮盒子和动态视频分辨率）和 其他一小部分程序Bug。&lt;/p&gt;
&lt;h3 id=&#34;3glew&#34;&gt;3.glew
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://glew.sourceforge.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The OpenGL Extension Wrangler Library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;glut或者freegult主要是OpenGL 1.0的基本函数功能；glew是使用OpenGL 2.0之后的一个工具函数。&lt;/p&gt;
&lt;p&gt;不同的显卡公司，也会发布一些只有自家显卡才支持的扩展函数，你要想用这数涵数，不得不去寻找最新的glext.h,有了GLEW扩展库，你就再也不用为找不到函数的接口而烦恼，因为GLEW能自动识别你的平台所支持的全部OpenGL高级扩展函数。也就是说，只要包含一个glew.h头文件，你就能使用gl,glu,glext,wgl,glx的全部函数。&lt;/p&gt;
&lt;p&gt;glew包含了OpenGL所需的核心。前面已经说过openGL的实现是显卡生产商，那么系统如何才能找到这些实现好的函数呢？而且不同的平台函数存放地方还不同，文件结构也不同。有没有一种方式能够自动找到OpenGL的函数？这就是glew的作用：用来找openGL的函数，并初始化，这样我们就能直接调用OpenGL的函数了。&lt;/p&gt;
&lt;h3 id=&#34;4glfw&#34;&gt;4.glfw
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.glfw.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;glfw is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan development on the desktop. It provides a simple API for creating windows, contexts and surfaces, receiving input and events.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;glfw无愧于其号称的lightweight的OpenGL框架，的确是除了跨平台必要做的事情都没有做，所以一个头文件，很少量的API，就完成了任务。glfw的开发目的是用于替代glut的。它是一个轻量级的，开源的，跨平台的library。支持OpenGL及OpenGL ES，用来管理窗口，读取输入，处理事件等。&lt;/p&gt;
&lt;p&gt;那么glfw有何优势呢？glut太老了，最后一个版本还是90年代的。freeglut完全兼容glut，算是glut的代替品，功能齐全，但是bug太多。稳定性也不好（不是我说的啊），glfw应运而生。&lt;/p&gt;
&lt;p&gt;总之，glfw是glut/freegult的升级和改进。glfw是用来显示窗口和捕捉窗口事件的一套API，可以理解成Qt和windows平台的WPF。OpenGL只是一套控制GPU的规则，并没有对于跨平台窗口显示和事件进行规定，所以需要一个显示显卡渲染的窗口，这就是glfw的作用。&lt;/p&gt;
&lt;h3 id=&#34;5glad&#34;&gt;5.glad
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://glad.dav1d.de/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Multi-Language GL/GLES/EGL/GLX/WGL Loader-Generator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;glad是继gl3w，glew之后，当前最新的用来访问OpenGL规范接口的第三方库。简单说glad是glew的升级版，就是说glew比较老，glad比较新。&lt;/p&gt;
&lt;h2 id=&#34;结论与项目使用&#34;&gt;结论与项目使用
&lt;/h2&gt;&lt;p&gt;窗口管理
老产品：glut/freeglut
替代品：glfw&lt;/p&gt;
&lt;p&gt;函数加载
老产品：glew
替代品：glad&lt;/p&gt;
&lt;p&gt;项目开发，通常有三种组合&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;freeglut+glew&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;glfw+glew&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;glfw+glad&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/opengl.jpg&#34;
	width=&#34;1289&#34;
	height=&#34;1130&#34;
	srcset=&#34;https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/opengl_hu_104ce5368136d67f.jpg 480w, https://whitedabaic.github.io/p/opengl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/opengl_hu_dda83c5ee3a4473a.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;114&#34;
		data-flex-basis=&#34;273px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_38446366/article/details/115328051&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OpenGL之gult/freeglut/glew/glfw/glad的联系与区别&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
